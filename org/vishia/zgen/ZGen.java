package org.vishia.zgen;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.vishia.cmd.ZGenExecuter;
import org.vishia.cmd.ZGenScript;
import org.vishia.mainCmd.MainCmd;
import org.vishia.mainCmd.MainCmdLoggingStream;
import org.vishia.mainCmd.MainCmdLogging_ifc;
import org.vishia.mainCmd.MainCmd_ifc;
import org.vishia.util.Assert;
import org.vishia.util.DataAccess;
import org.vishia.util.FileSystem;
import org.vishia.util.StringPart;
import org.vishia.util.StringPartScan;
import org.vishia.util.StringPartFromFileLines;
import org.vishia.util.StringPartScan;
import org.vishia.util.UnexpectedException;
import org.vishia.xmlSimple.SimpleXmlOutputter;
import org.vishia.xmlSimple.XmlException;
import org.vishia.xmlSimple.XmlNode;
import org.vishia.zbnf.ZbnfJavaOutput;
import org.vishia.zbnf.ZbnfParser;


/**Script executer and text generator with main.
 * @author Hartmut Schorrig
 *
 */
public class ZGen
{
  
  /**Version, history and license.
   * <ul>
   * <li>2014-02-16 Hartmut chg: execute(... String sCurrdir) now with current directory from outside.
   *   translateAndSetGenCtrl( File fileScript, ...) with the script file.
   *   Argument -currdir=PATH for command line invocation {@link #main(String[])}
   *   Build of script variable currdir, scriptfile, scriptdir with them in {@link ZGenExecuter#genScriptVariables(ZGenScript, boolean, Map, CharSequence)}.
   * <li>2013-10-27 Hartmut chg: {@link #jbatch(String, org.vishia.cmd.ZGenExecuter.ExecuteLevel)}
   * <li>2012-10-03 created. Backgorund was the {@link org.vishia.zmake.Zmake} generator, but that is special for make problems.
   *   A generator which converts ZBNF-parsed data from an Java data context to output texts in several form, documenation, C-sources
   *   was need.
   * </ul>
   * 
   * <b>Copyright/Copyleft</b>:
   * For this source the LGPL Lesser General Public License,
   * published by the Free Software Foundation is valid.
   * It means:
   * <ol>
   * <li> You can use this source without any restriction for any desired purpose.
   * <li> You can redistribute copies of this source to everybody.
   * <li> Every user of this source, also the user of redistribute copies
   *    with or without payment, must accept this license for further using.
   * <li> But the LPGL ist not appropriate for a whole software product,
   *    if this source is only a part of them. It means, the user
   *    must publish this part of source,
   *    but don't need to publish the whole source of the own product.
   * <li> You can study and modify (improve) this source
   *    for own using or for redistribution, but you have to license the
   *    modified sources likewise under this LGPL Lesser General Public License.
   *    You mustn't delete this Copyright/Copyleft inscription in this source file.
   * </ol>
   * If you are intent to use this sources without publishing its usage, you can get
   * a second license subscribing a special contract with the author. 
   * 
   * @author Hartmut Schorrig = hartmut.schorrig@vishia.de
   * 
   * 
   */
  //@SuppressWarnings("hiding")
  static final public String sVersion = "2014-02-16";

  
  public static class Args{
    
    /**path to the script file for the generation or execution script of ZGen.*/
    String sFileScript;
    
    /**path to the text output file which is generated by ZGen. May be null, then no text output. */
    String sFileTextOut;
    
    /**If given the absolute or maybe relative path for the start currdir.
     * This value is used as absolute start path for a <code>currdir = < objExpr?path></code> - assignment in the script.
     */
    String sCurrdir;
    
    /**path to some output files for debugging, maybe left null. */
    File fileTestXml;
    
    /**User arguments, stored as script variable "$1" till "$n" */
    List<String> userArgs = new ArrayList<String>();
  }
  

  //protected final MainCmdLogging_ifc log;
  
  //protected final Args args;
  
  //protected final ZGenExecuter executer;
  
  /*
  public ZGen(Args args, MainCmdLogging_ifc log){
    this.log = log;
    this.args = args;
    this.executer = new ZGenExecuter(log);
  }
  */
  
  /**Does not support {@link #execute()}, only {@link #translateAndSetGenCtrl(File, File)}.
   * @param log
   */
  /*
  public ZGen(MainCmdLogging_ifc log){
    this.log = log;
    this.args = null;
    this.executer = null;
  }
  */
  
  /** main started from java*/
  public static void main(String [] sArgs)
  { 
    smain(sArgs, true);
  }


  /**Invocation from another java program without exit the JVM
   * @param sArgs same like {@link #main(String[])}
   * @return "" or an error String
   */
  public static String smain(String[] sArgs){ return smain(sArgs, false); }

  
  private static String smain(String[] sArgs, boolean shouldExitVM){
    String sRet = null;
    Args args = new Args();
    CmdLine mainCmdLine = new CmdLine(args, sArgs); //the instance to parse arguments and others.
    try{
      try{ mainCmdLine.parseArguments(); }
      catch(Exception exception)
      { sRet = "Jbat - Argument error ;" + exception.getMessage();
        mainCmdLine.report(sRet, exception);
        mainCmdLine.setExitErrorLevel(MainCmd_ifc.exitWithArgumentError);
      }
      if(args.sFileScript !=null){
        if(sRet == null)
        { /** The execution class knows the SampleCmdLine Main class in form of the MainCmd super class
              to hold the contact to the command line execution.
          */
          try{ 
            ZGenExecuter executer = new ZGenExecuter(mainCmdLine);
            FileWriter fout = null;
            Appendable out = null;
            if(args.sFileTextOut !=null){
              try{
                File fileOut = new File(args.sFileTextOut);
                out = fout = new FileWriter(fileOut);
              } catch(IOException exc){
                sRet = "ZGen - cannot create output text file;"; 
              }
            } else {
              out = System.out;
            }
            if(sRet == null){
              File fileIn = new File(args.sFileScript);
              char nrArg = '1';
              for(String argu: args.userArgs){
                executer.setScriptVariable("$" + nrArg, 'S', argu, true);
                nrArg +=1;
              }
              CharSequence cRet = execute(executer, fileIn, out, args.sCurrdir, true, args.fileTestXml, mainCmdLine);
              sRet = cRet == null ? null : cRet.toString();
            }
            if(fout !=null){
              fout.close();
            }
            if(sRet !=null){
              mainCmdLine.writeError(sRet);
            }
          }
          catch(Exception exception)
          { //catch the last level of error. No error is reported direct on command line!
            sRet = "ZGen - Any internal error;" + exception.getMessage();
            mainCmdLine.report(sRet, exception);
            exception.printStackTrace(System.out);
            mainCmdLine.setExitErrorLevel(MainCmd_ifc.exitWithErrors);
          }
        }
      } else {
        mainCmdLine.writeHelpInfo();
      }
    } catch(Exception exc){
      sRet = exc.getMessage();
    }
    
    if(shouldExitVM) { mainCmdLine.exit(); }
    return sRet;
  }


  
  
  /**Parses the script and executes it independent from any other inputs.
   * It executes the script like a batch with access to any Java classes.
   * Therefore it is a 'Java batch executer'.
   * @param script Path to the script.
   * @return any error string. null if successfull.
   * @throws IllegalAccessException 
   */
  public static CharSequence jbatch(String script) throws IllegalAccessException{
    return execute(script);
  }
  
  
  /**Parses the script and executes it with a given ZGen ExecuterLevel.
   * That is the possibility to start a independent ZGen execution in a ZGen script itself.
   * @param script Path to the script.
   * @param execLevel subroutine level where this is called.
   *   All variables of this level are used as script variables for the script to execute.
   *   Especially the currdir of the level is used as script level currdir
   * @return TODO ? any error string. null if successfully.
   */
  public static CharSequence jbatch(
      File script
    , ZGenExecuter.ExecuteLevel execLevel
  ) throws IllegalAccessException{
    //return execute(script, execLevel.log());
    
    boolean bWaitForThreads = false;
    StringBuilder u = new StringBuilder();
    //ZGenScript genScript = null; //gen.parseGenScript(fileGenCtrl, null);
    MainCmdLogging_ifc log = execLevel.log();
    ZGenExecuter executer = new ZGenExecuter(log);
    //Copy all local variables of the calling level as script variables.
    try { 
      ZGenScript genScript = translateAndSetGenCtrl(script, null, log);
      //the script variables are build from the local ones of the calling script:
      executer.genScriptVariables(genScript, true, execLevel.localVariables, null);
      executer.execute(genScript, true, bWaitForThreads, u, null);
      //zgenExecuteLevel.execute(genScript.getMain().subContent, u, false);
    } catch (Exception exc) {
      String sError = exc.getMessage();
      System.err.println(sError);
    }
    return u.toString();
  }
  
  
  public static CharSequence execute(String script){
    StringPartScan spScript = new StringPartScan(script);
    MainCmdLogging_ifc log = new MainCmdLoggingStream(System.out);
    ZGenExecuter zgenExecuter = new ZGenExecuter(log);
    return execute(zgenExecuter, null, spScript, null, null, true, null, log);
  }
  
  
  public static CharSequence execute(File script, MainCmdLogging_ifc log){
    return execute(null, script, null, null, true, null, log);
  }
  
  
  
  
  public static CharSequence execute(ZGenExecuter executer, File fileScript, Appendable out, String sCurrdir, boolean accessPrivate
      , File testOut, MainCmdLogging_ifc log) {
    String sError = null;
    int lengthBufferGenctrl = (int)fileScript.length();
    try { StringPartScan spGenCtrl = new StringPartFromFileLines(fileScript, lengthBufferGenctrl, "encoding", null);
      File fileParent = FileSystem.getDir(fileScript);
      return execute(executer, fileScript, spGenCtrl, out, sCurrdir, accessPrivate, testOut, log);
    } catch(IOException exc){
      sError = exc.getMessage();
      System.err.println("ZGen - Error script nor found; " + fileScript.getAbsolutePath() + "; " + sError); 
      
    }
    return sError;
  }  

  /**Generates a text described with a file given script from any data. This is the main routine of this class.
   * @param userData The data pool where all data are stored
   * @param fileScript The script to generate the text context
   * @param out output for the text
   * @param accessPrivate if true then private data are accessed too. The accessing of private data may be helpfull
   *  for debugging. It is not recommended for general purpose! The access mechanism is given with 
   *  {@link java.lang.reflect.Field#setAccessible(boolean)}.
   * @param testOut if not null then outputs a data tree of the generate script.
   * @return null if no error or an error string.
   */
  public static CharSequence execute(
      ZGenExecuter executer
    , File fileScript  
    , StringPartScan script
    , Appendable out
    , String sCurrdir
    , boolean accessPrivate
    , File testOut
    , MainCmdLogging_ifc log
  ) {
    CharSequence sError = null;
    MainCmdLogging_ifc log1 = log == null ? new MainCmdLoggingStream(System.out) : log;
    ZGenScript genScript = null; //gen.parseGenScript(fileGenCtrl, null);
    try { genScript = translateAndSetGenCtrl(fileScript, script, log, testOut);
    } catch (ParseException exc){
      sError = exc.getMessage();
      System.err.println("ZGen - Error parsing genscript; "  + sError); 
    } catch (Exception exc) {
      sError = exc.getMessage();
      System.err.println(Assert.exceptionInfo("ZGen - exception execute parsing;", exc,0,10));
    }
    //genScript = parseGenScript(fileScript, testOut);
    if(sError == null) { // && out !=null){
      try{
        ZGenExecuter executer1 = executer == null ? new ZGenExecuter(log) : executer;
        sError = executer1.execute(genScript, accessPrivate, true, out, sCurrdir);
        //out.close();
      } catch(Exception exc){
        System.err.println(Assert.exceptionInfo("", exc, 0, 4));
      }
    }
    //String sError = generator.generate(zbnfResultData, fileScript, fOut, true);
    return sError;
  }
  
  
  
  public static ZGenScript translateAndSetGenCtrl(File fileScript, MainCmdLogging_ifc log) 
  throws FileNotFoundException, IllegalArgumentException, IllegalAccessException, InstantiationException, IOException, ParseException, XmlException 
  {
    return translateAndSetGenCtrl(fileScript, null, log);
  }
  
  
  public static ZGenScript translateAndSetGenCtrl(File fileGenCtrl, File checkXmlOut, MainCmdLogging_ifc log) 
  throws FileNotFoundException, IllegalArgumentException, IllegalAccessException, InstantiationException, IOException, ParseException, XmlException 
  {
    int lengthBufferGenctrl = (int)fileGenCtrl.length();
    StringPartScan spGenCtrl = new StringPartFromFileLines(fileGenCtrl, lengthBufferGenctrl, "encoding", null);
    return translateAndSetGenCtrl(fileGenCtrl, spGenCtrl, log, checkXmlOut);
  }
  
  
  public static ZGenScript translateAndSetGenCtrl(String spGenCtrl, MainCmdLogging_ifc log) 
  throws IllegalArgumentException, IllegalAccessException, InstantiationException, ParseException 
  {
    try{ 
      return translateAndSetGenCtrl(null, new StringPartScan(spGenCtrl), log, null);
    } catch(IOException exc){ throw new UnexpectedException(exc); }
  }
  
  
  /**Translates with a new Parser and the given script in text format.
   * @param fileParent The directory which is the anchor for included scripts. Maybe null if included scripts does not exists.
   * @param spGenCtrl The script in form of StringPartScan. User new {@link StringPartScan#StringPartScan(CharSequence)}
   *   to create one with a String given syntax.
   * @param checkXmlOutput may be null, for output the script in XML form.
   * @param log
   * @return
   * @throws ParseException
   * @throws IllegalArgumentException
   * @throws IllegalAccessException
   * @throws InstantiationException
   * @throws FileNotFoundException
   * @throws IOException
   */
  public static ZGenScript translateAndSetGenCtrl(StringPartScan spGenCtrl, MainCmdLogging_ifc log) 
  throws ParseException, IllegalArgumentException, IllegalAccessException, InstantiationException 
  {
    try { 
      return translateAndSetGenCtrl(null, spGenCtrl, log, null);
    }catch(IOException exc){ throw new UnexpectedException(exc); }
  }
  
  
  
  /**Translates with a new Parser and the given script in text format.
   * @param fileParent The directory which is the anchor for included scripts. Maybe null if included scripts does not exists.
   * @param spGenCtrl The script in form of StringPartScan. User new {@link StringPartScan#StringPartScan(CharSequence)}
   *   to create one with a String given syntax.
   * @param checkXmlOutput may be null, for output the script in XML form.
   * @param log
   * @return
   * @throws ParseException
   * @throws IllegalArgumentException
   * @throws IllegalAccessException
   * @throws InstantiationException
   * @throws FileNotFoundException
   * @throws IOException
   */
  private static ZGenScript translateAndSetGenCtrl(File fileScript, StringPartScan spGenCtrl, 
      MainCmdLogging_ifc log, File checkXmlOutput) 
  throws ParseException, IllegalArgumentException, IllegalAccessException, InstantiationException, FileNotFoundException, IOException 
  { MainCmdLogging_ifc log1;
    if(log == null){
      log1 = new MainCmdLoggingStream(System.out);
    } else { log1 = log; }
    ZbnfParser parserGenCtrl = new ZbnfParser(log1); //console);
    parserGenCtrl.setSyntax(ZGenSyntax.syntax);
    ZGenScript script = new ZGenScript(log, fileScript);
    File fileParent = FileSystem.getDir(fileScript);
    ZGenScript.ZbnfZGenScript zbnfGenCtrl = new ZGenScript.ZbnfZGenScript(script);
    translateAndSetGenCtrl(script, zbnfGenCtrl, parserGenCtrl, fileParent, spGenCtrl, checkXmlOutput, log1);
    return script;
  }
    
  
  
  
  
  /**Translates with a given parser which knows the syntax of ZGen already.
   * The parser may be reused if more as one script should be translated on after another.
   * @param parserGenCtrl The parser should know the correct syntax already. One should use
   *   {@link ZGenSyntax#syntax} to set {@link ZbnfParser#setSyntax(String)}. One should use an 
   *   abbreviating syntax for experience.
   * @param fileParent The directory which is the anchor for included scripts. Maybe null if included scripts does not exists.
   * @param spGenCtrl The script in form of StringPartScan. User new {@link StringPartScan#StringPartScan(CharSequence)}
   *   to create one with a String given syntax.
   * @param checkXmlOutput may be null, for output the script in XML form.
   * @param log
   * @return
   * @throws ParseException
   * @throws IllegalArgumentException
   * @throws IllegalAccessException
   * @throws InstantiationException
   * @throws FileNotFoundException
   * @throws IOException
   */
  private static void translateAndSetGenCtrl(ZGenScript script, ZGenScript.ZbnfZGenScript zbnfGenCtrl, ZbnfParser parserGenCtrl, File fileParent, StringPartScan spGenCtrl
      , File checkXmlOutput, MainCmdLogging_ifc log) 
  throws ParseException, IllegalArgumentException, IllegalAccessException, InstantiationException, FileNotFoundException, IOException 
  { boolean bOk;
    
    bOk = parserGenCtrl.parse(spGenCtrl);
    if(!bOk){
      String sError = parserGenCtrl.getSyntaxErrorReport();
      throw new ParseException("\n" + sError,0);
    }
    if(checkXmlOutput !=null){
      //XmlNodeSimple<?> xmlParseResult = parserGenCtrl.getResultTree();
      XmlNode xmlParseResult = parserGenCtrl.getResultTree();
      SimpleXmlOutputter xmlOutputter = new SimpleXmlOutputter();
      OutputStreamWriter xmlWriter = new OutputStreamWriter(new FileOutputStream(checkXmlOutput));
      xmlOutputter.write(xmlWriter, xmlParseResult);
      xmlWriter.close();
    }
    //if(log.getReportLevel() >= MainCmdLogging_ifc.fineInfo){
    //  parserGenCtrl.reportStore((Report)log, MainCmdLogging_ifc.fineInfo, "Zmake-GenScript");
    //}
    //write into Java classes:
    /**Helper to transfer parse result into the java classes {@link ZbnfZGenScript} etc. */
    final ZbnfJavaOutput parserGenCtrl2Java = new ZbnfJavaOutput(log);
    //
    //create a new instance of script-file for any file, especially for included.
    zbnfGenCtrl.scriptfile = new ZGenScript.Scriptfile();
    parserGenCtrl2Java.setContent(ZGenScript.ZbnfZGenScript.class, zbnfGenCtrl, parserGenCtrl.getFirstParseResult());
    //
    //get the main routine from the first parsed file, store it, set it after processing includefiles.
    //
    ZGenScript.Subroutine mainRoutine = zbnfGenCtrl.scriptfile.getMainRoutine();
    //
    if(zbnfGenCtrl.scriptfile.includes !=null){
      //parse includes after processing this file, because the zbnfGenCtrl.includes are not set before.
      //If one include contain a main, use it. But override the main after them, see below.
      for(String sFileInclude: zbnfGenCtrl.scriptfile.includes){
        final File fileInclude;
        if(FileSystem.isAbsolutePath(sFileInclude)){
          fileInclude= new File(sFileInclude);
        } else {
          fileInclude= new File(fileParent, sFileInclude);
        }
        if(!fileInclude.exists()){
          System.err.printf("TextGenScript - translateAndSetGenCtrl, included file not found; %s\n", fileInclude.getAbsolutePath());
          throw new FileNotFoundException("TextGenScript - translateAndSetGenCtrl, included file not found: " + fileInclude.getAbsolutePath());
        }
        File fileIncludeParent = FileSystem.getDir(fileInclude);
        int lengthBufferGenctrl = (int)fileInclude.length();
        StringPartScan spGenCtrlSub = new StringPartFromFileLines(fileInclude, lengthBufferGenctrl, "encoding", null);
        //
        //included script, call recursively.
        translateAndSetGenCtrl(script, zbnfGenCtrl, parserGenCtrl, fileIncludeParent, spGenCtrlSub, checkXmlOutput, log);
      }
    }
    //
    //set the main routine from the first parsed file if existing:
    //
    if(mainRoutine !=null){  //the main routine of the main file wins against includes if exists.
      script.setMainRoutine(mainRoutine);
    }
  }
  
  

  
  
  protected static class CmdLine extends MainCmd
  {

    public final Args argData;

    protected final MainCmd.Argument[] argList =
    { new MainCmd.Argument("", "<INPUT>    pathTo ZGen-File to execute"
        , new MainCmd.SetArgument(){ @Override public boolean setArgument(String val){ 
          if(argData.sFileScript == null){ argData.sFileScript = val; }
          else {argData.userArgs.add(val); }
          return true; 
        }})
    , new MainCmd.Argument("-t", ":<OUTEXT> pathTo text-File for output"
        , new MainCmd.SetArgument(){ @Override public boolean setArgument(String val){ 
          argData.sFileTextOut = val; return true;
        }})
    , new MainCmd.Argument("-currdir", ":<PATH> path of the current dir. If file-path, then it's dir."
        , new MainCmd.SetArgument(){ @Override public boolean setArgument(String val){ 
          argData.sCurrdir = val; return true;
        }})
    , new MainCmd.Argument("-debug", ":<TEST.xml> pathTo Test-File"
        , new MainCmd.SetArgument(){ @Override public boolean setArgument(String val){ 
          argData.fileTestXml = new File(val); return true;
        }})
    , new MainCmd.Argument("-u", ":userArgs"
        , new MainCmd.SetArgument(){ @Override public boolean setArgument(String val){ 
          argData.userArgs.add(val); 
          return true; 
        }})
    };


    protected CmdLine(Args argData, String[] sCmdlineArgs){
      super(sCmdlineArgs);
      this.argData = argData;
      super.addAboutInfo("Execution and Generation of ZGen-Files");
      super.addAboutInfo("made by HSchorrig, Version 1.0, 2013-07-11..2013-12-31");
      super.addArgument(argList);
      super.addStandardHelpInfo();
      
    }
    
    @Override protected void callWithoutArguments()
    { //overwrite with empty method - it is admissible.
    }

    
    @Override protected boolean checkArguments()
    {
      return true;
    } 
    
    @Override public void writeHelpInfo(){
      super.writeHelpInfo();
      System.out.println("=== Syntax of a jbat script===");
      System.out.println(ZGenSyntax.syntax);
    }

  }
  
  
}
