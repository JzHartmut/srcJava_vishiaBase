package org.vishia.odg.data;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.vishia.util.DataAccess;
import org.vishia.util.Debugutil;
import org.vishia.xmlReader.XmlJzReader;
import org.vishia.xmlReader.XmlCfg.XmlCfgNode;


//import java.util.LinkedList;
//import java.util.List;

/**This file is generated by {@link org.vishia.genJavaOutClass.GenJavaOutClass}.
 * It defines the usage level for the data class for the parse results. 
 * This usage classes can be adapted. */
public class XmlForOdg extends XmlForOdg_Base {

  
  /**Version, License and History: See {@link XmlJzReader}.
   * <ul>
   * <li>2022-06-26 new: elaborate content for evaluation. 
   * <li>2022-06-06 Creation originally via generation.
   * </ul>
    * 
   * <b>Copyright/Copyleft</b>:
   * For this source the LGPL Lesser General Public License,
   * published by the Free Software Foundation is valid.
   * It means:
   * <ol>
   * <li> You can use this source without any restriction for any desired purpose.
   * <li> You can redistribute copies of this source to everybody.
   * <li> Every user of this source, also the user of redistribute copies
   *    with or without payment, must accept this license for further using.
   * <li> But the LPGL is not appropriate for a whole software product,
   *    if this source is only a part of them. It means, the user
   *    must publish this part of source,
   *    but don't need to publish the whole source of the own product.
   * <li> You can study and modify (improve) this source
   *    for own using or for redistribution, but you have to license the
   *    modified sources likewise under this LGPL Lesser General Public License.
   *    You mustn't delete this Copyright/Copyleft inscription in this source file.
   * </ol>
   * If you are intent to use this sources without publishing its usage, you can get
   * a second license subscribing a special contract with the author. 
   * 
   * @author Hartmut Schorrig = hartmut.schorrig@vishia.de
   * 
   */
  public static final String version = "2022-06-26";


  public Map<String, String> idxStyle;

  //public final List<Module> listModule = new LinkedList<Module>();
  
  public final List<Connection> listConnection = new LinkedList<Connection>();
  
  /**This is only to detect twice same modules, contains only named modules. */
  private final Map<String, Module> idxModuleByName = new TreeMap<String, Module>();
  
  /**This are the sorted modules for comparable report alternatively to the {@link #listModule}. */
  public final Map<String, Module> idxAllModule = new TreeMap<String, Module>();
  
  
  
  public final Map<String, Port> idxPortById = new TreeMap<String, Port>();
  
  public final Map<String, XrefConn> idxXrefById = new TreeMap<String, XrefConn>();
  
  /**Points on a connection line acts similar as Xref, only they have more as one connection and no name. */
  //public final Map<String, XrefConn> idxConnLineById = new TreeMap<String, XrefConn>();
  
  public final Map<String, XrefConn> idxXrefByName = new TreeMap<String, XrefConn>();
  
  public void prepareData ( ) {
    XmlForOdg.Office_document_content doc = this.get_office_document_content();
    XmlForOdg.Office_body body = doc.get_office_body();
    XmlForOdg.Office_automatic_styles styles = doc.get_office_automatic_styles();
    this.idxStyle = styles.prepStyles();
    XmlForOdg.Office_drawing drawing = body.get_office_drawing();
    
    for(XmlForOdg.Draw_page page : drawing.get_draw_page()) {
      for(XmlForOdg.Draw_g group:  page.get_draw_g()) {      // general: a module is inside a group
        System.out.println("== group");
        Module mdl = Module.gatherInternals(group, this);
        this.idxAllModule.put(mdl.name(), mdl);
        //this.listModule.add(mdl);
        
    } }
    for(XmlForOdg.Draw_page page : drawing.get_draw_page()) {
      for(XmlForOdg.Draw_custom_shape xrefConn:  page.get_draw_custom_shape()) {     
        gatherXref(xrefConn);
    } }
    for(XmlForOdg.Draw_page page : drawing.get_draw_page()) {
      for(XmlForOdg.Draw_connector con:  page.get_draw_connector()) {      // general: a module is inside a group
        gatherConnection(con);
    } }
    fulfillConnectionsUsingXref();
    buildAggregations();
  }

  
  private void gatherXref ( Draw_custom_shape xref ) {
    String drawStyle = xref.draw_style_name;
    String drawStyleParent = this.idxStyle.get(drawStyle);
    String id = xref.draw_id;
    String name = xref.getText();
    if(drawStyleParent.equals("xref")) { 
      if( id !=null && name !=null) {
        char[] spec = new char[2];
        name = detectFuncSpec(name, spec);
        XrefConn xrefConn = this.idxXrefByName.get(name);
        if(xrefConn==null) {
          xrefConn = new XrefConn(name, id);
          this.idxXrefByName.put(name, xrefConn);  
        }
        this.idxXrefById.put(id, xrefConn);
      } else {
        System.err.println("xref id or name missing");
      }
    } else if(drawStyleParent.equals("oodgConnLine")) { 
      XrefConn connLine = this.idxXrefById.get(id);
      if(connLine == null) {
        connLine = new XrefConn(null, id);
        this.idxXrefById.put(id, connLine);
      } else {
        assert(false);  //should be defined only ones.
      }
    } else {
      System.err.println("shape not recognized");
    }
  }
  
  
  private static String detectFuncSpec(String name, char[] spec) {
    final String name1;
    int posDir = name.indexOf('<');
    if(posDir <0) { posDir = name.indexOf('>'); }
    if(posDir >=0) {
      final int ixSpec;
      if(posDir < 2) {
        ixSpec = 0;
        name1 = name.substring(posDir+1).trim();
      } else {
        ixSpec = 1;
        name1 = name.substring(0,posDir).trim();
      }
      if(spec !=null) { 
        spec[ixSpec] = name.charAt(posDir);
        spec[(ixSpec + 1) & 1] = '\0';  //0 for 1, 1 for 0
      }
    } else {
      name1 = name.trim();
      if(spec !=null) { spec[0] = spec[1] = '\0'; }
    }
    return name1;
  }
  
  private void gatherConnection(Draw_connector con) {
    String style = con.get_draw_style_name();
    String start = con.get_draw_start_shape();
    String startpoint = con.get_draw_start_glue_point();
    String end = con.get_draw_end_shape();
    String endpoint = con.get_draw_end_glue_point();
    String id = con.get_svg_d();
    if(start ==null || end==null) {
      errorMsg("dangling connection, without start or end", id + " "+ start + " " +end);
    } else {
      XrefConn xref1 = this.idxXrefById.get(start);
      Port port1 = null;
      if(xref1 ==null) {
        port1 = this.idxPortById.get(start);
      }
      Port port2 = null; 
      XrefConn xref2 = this.idxXrefById.get(end);
      if(xref2 == null) {                                    // either xref1/2 will be set firstly or port1/2, not both.
        port2 = this.idxPortById.get(end);
      }
      if(port1 !=null && port1.kind == Port.Kind.src && xref2 !=null) {
        xref2.setSrc(port1);
      }
      if(port2 !=null && port2.kind == Port.Kind.src && xref1 !=null) {
        xref1.setSrc(port2);
      }
      if((port1 !=null || xref1 !=null) && (port2 !=null || xref2 !=null)) {
        Connection conn = new Connection("name", id, port1, xref1, port2, xref2);
        this.listConnection.add(conn);
        System.out.println("  " + conn.toString());
      }
      else {
        errorMsg("dangling connection, port or xref not found", id + " "+ start + " " +end);
      }
    }
  }
  
  
  private void fulfillConnectionsUsingXref ( ) {
    boolean bFulfilled;
    int ctAbort = 100;
    do {
      bFulfilled = true;
      for(Connection conn : this.listConnection) {
        Port portRet = checkPort(conn.port1, conn.xref1, conn.xref2, conn.id);
        if(portRet == null) { bFulfilled = false; }
        else if(portRet != conn.port1) {
          assert(conn.port1 == null);
          conn.port1 = portRet;                              // fulfill the port.
        }
        portRet = checkPort(conn.port2, conn.xref2, conn.xref1, conn.id);
        if(portRet == null) { bFulfilled = false; }
        else if(portRet != conn.port2) {
          assert(conn.port2 == null);
          conn.port2 = portRet;                              // fulfill the port.
        }
      }
    } while(!bFulfilled && --ctAbort >0);
    if(!bFulfilled) {
      assert(ctAbort ==0);
      System.err.println("connection error");
    }
    for(Map.Entry<String, XrefConn> exref : this.idxXrefByName.entrySet()) {
      XrefConn xref = exref.getValue();
      if(xref.src == null) {
        System.err.println("Xref has no source: " + xref.name);
      }
    }
  }

  private void buildAggregations ( ) {

    for(Connection conn : this.listConnection) {
        
      if(conn.id.equals("M8802 6855h-902v-300h-926"))
        Debugutil.stop();
      
      if(conn.port1 !=null && conn.port1.kind == Port.Kind.aggr) {
        Module mdlStart = conn.port1.mdl;
        mdlStart.aggregations.add(conn);
      }
      if(conn.port2 !=null && conn.port2.kind == Port.Kind.aggr) {
        Module mdl = conn.port2.mdl;
        mdl.aggregations.add(conn);
      }
      if(conn.port1 !=null && conn.port1.kind == Port.Kind.src) {
        Module mdlStart = conn.port1.mdl;
        mdlStart.aggrSrcs.add(conn);
      }
      if(conn.port2 !=null && conn.port2.kind == Port.Kind.src) {
        Module mdl = conn.port2.mdl;
        mdl.aggrSrcs.add(conn);
      }
      
    }
  }
  
  
  
  private Port checkPort(Port port, XrefConn xrefOwn, XrefConn xrefOther, String id) {
    final Port portRet;                         // note: null if port ==null, means not fulfilled
    if(port == null) {
      if(xrefOwn == null) {
        portRet = Port.dangling;
        System.err.println("dangling connection id=" + id);
      } else if(xrefOwn.src() !=null){                // port == null, but xref given: 
        portRet = xrefOwn.src();                           // fulfill port with src of Xref, maybe null
      } else {
        portRet = null;                              // missing src, repeat
      }
    } else {
      portRet = port;          //same returned.
    }
    if(portRet !=null && xrefOther !=null && xrefOther.src() == null) { // port given, 
      if(portRet.kind == Port.Kind.src) {
        xrefOther.setSrc(portRet);                   // if possible, set src of Xref
      }
    }
    return portRet;
  }
  
  
  
  
  private void errorMsg(String msg, String ...params ) {
    System.err.append(msg);
    for(String param: params) {
      System.err.append(", ").append(param);
    }
    System.err.append('\n');
  }
  
  
  
  /**This is a module detected in office draw.
   *
   */
  public static class Module {
    public String typeName;
    
    private String name;
    
    public String id;
    
    public Map<String, Port> idxAggr = new TreeMap<String, Port>();
    public Map<String, Port> idxInp = new TreeMap<String, Port>();
    public Map<String, Port> idxSrc = new TreeMap<String, Port>();
  
    public List<Connection> aggregations = new LinkedList<Connection>();
    
    public List<Connection> aggrSrcs = new LinkedList<Connection>();
    
     
    Module ( ) {
    }
    
    public String name() { 
      if(this.name !=null && this.name.length() >0) return this.name;
      else return this.typeName;
    }
    
    public static Module gatherInternals ( Draw_g group, XmlForOdg odg) {
      Module mdl = new Module();
      for(XmlForOdg.Draw_frame textFrame: group.get_draw_frame()) {
        String text = null;
        String drawStyle = textFrame.get_draw_style_name();
        String drawTextStyle = textFrame.get_draw_text_style_name();
        String id = textFrame.get_draw_id();
        String posId = textFrame.get_svg_x() + textFrame.get_svg_y();
        String drawStyleParent = odg.idxStyle.get(drawStyle);
        //String drawTextStyleParent = odg.idxStyle.get(drawTextStyle);
        
        XmlForOdg.Text_p textp = textFrame.get_draw_text_box().get_text_p();
        if(textp !=null) {
          XmlForOdg.Text_span textspan = textp.get_text_span();
          if(textspan !=null) {
            text = textspan.get_text();
          } else {
            text = textp.get_text_s();
//            System.out.println("text:frame without text:span");
          }
        }
        if(drawStyleParent.equals("oodg-mdlTitle")) {
          if(mdl.typeName !=null && ! mdl.typeName.equals(text)) {
            odg.errorMsg("faulty type on second module", mdl.name, text);
          }
          mdl.typeName = text;
          mdl.id = id;
        } else if(drawStyleParent.equals("oodgName")) {
          mdl.name = text;
          mdl = checkTwiceSameModules(mdl, odg);
         
        } else if(drawStyleParent.startsWith("oodgPort") || drawStyleParent.startsWith("port")) {
          char[] spec = new char[2];
          String determ = detectFuncSpec(text, spec);
          int posSep = determ.indexOf(':');
          final String name, type;
          if(posSep >=0) {
            name = determ.substring(0, posSep).trim();
            type = determ.substring(posSep+1).trim();
          } else {
            type = determ.trim();
            name = null;
          }
          if(id == null) { id = posId; }
          Port port = new Port(mdl, name, type, id, spec);
          odg.idxPortById.put(id, port);
          if(port.kind == Port.Kind.aggr) {
            mdl.idxAggr.put(port.key, port);
          } else if(port.kind == Port.Kind.inp) {
            mdl.idxInp.put(port.key, port);
          } else {
            assert(port.kind == Port.Kind.src);
            mdl.idxSrc.put(port.key, port);
          }
        } else {
          odg.errorMsg("faulty format: ", text, drawStyleParent);
        }
      }
      System.out.println(mdl);
      return mdl;
    } //gatherInternals
    
    
    
    private static Module checkTwiceSameModules(Module mdl, XmlForOdg odg) {
      Module mdl2 = odg.idxModuleByName.get(mdl.name);
      if(mdl2 !=null) {                                // module with same name also existing, merge the data:
        if(mdl.typeName !=null && !mdl2.typeName.equals(mdl.typeName)) {
          odg.errorMsg("Module with same name but different type", mdl.name, mdl.typeName);
          return mdl;
        } else {
          for(Map.Entry<String, Port> e : mdl.idxAggr.entrySet()) {
            Port port = e.getValue();
            Port port2 = mdl2.idxAggr.get(port.key);
            if(port2 !=null) {                         // same port is already existing
              odg.idxPortById.put(port.id, port2);     // Store the always existing Port with the given Id with the existing Port
            } else {
              mdl2.idxAggr.put(port.key, port);        // Store the here new regognized port
            }
          }
          for(Map.Entry<String, Port> e : mdl.idxInp.entrySet()) {
            Port port = e.getValue();
            Port port2 = mdl2.idxInp.get(port.key);
            if(port2 !=null) {                         // same port is already existing
              odg.idxPortById.put(port.id, port2);     // Store the always existing Port with the given Id with the existing Port
            } else {
              mdl2.idxInp.put(port.key, port);        // Store the here new regognized port
            }
          }
          for(Map.Entry<String, Port> e : mdl.idxSrc.entrySet()) {
            Port port = e.getValue();
            Port port2 = mdl2.idxSrc.get(port.key);
            if(port2 !=null) {                         // same port is already existing
              odg.idxPortById.put(port.id, port2);         // replace the already stored Port with the given Id with the used Port
            } else {
              mdl2.idxSrc.put(port.key, port);        // Store the here new regognized port
            }
          }
          return mdl2;
        }
      } else {
        odg.idxModuleByName.put(mdl.name, mdl);
        return mdl;
      }
    }
    
    
  
    public CharSequence showMdlAggregations ( ) {
      StringBuilder out = new StringBuilder(1000);
      out.append("\n== Module ").append(this.name()).append('\n');
      for(Map.Entry<String, Port> einp: this.idxAggr.entrySet()) {
        out.append("  < ").append(einp.toString()).append('\n');
      }
      for(Map.Entry<String, Port> einp: this.idxInp.entrySet()) {
        out.append("  > ").append(einp.toString()).append("\n");
      }
      for(Map.Entry<String, Port> einp: this.idxSrc.entrySet()) {
        out.append("  = ").append(einp.toString()).append("\n");
      }
      for(Connection aggr: this.aggregations) {
        out.append("  aggr: ").append(aggr).append("\n");
      }
      for(Connection aggr: this.aggrSrcs) {
        out.append("  aggrSrc: ").append(aggr).append("\n");
      }
      return out;
    }
    
    
    
    @Override public String toString() {
      return (this.name !=null ? name : "") + " : " + this.typeName;
    }
    
  } //Module
  
  
  /**One port on a module.
   *
   */
  public static class Port {
    
    public static char[] emptySpec = { '\0', '\0'};
    
    /**This port is used to fulfill a non existing connection,
     * firstly to finish searching for open connections. 
     */
    public static Port dangling = new Port(null, "?dangling", "?Dangling", null, emptySpec);
    
    enum Kind { aggr, src, inp };
    
    public final Module mdl;
    
    public final String name, typeName, key;
    
    public final String id;

    public final Kind kind;
    
    public Port(Module mdl, String name, String typeName, String id, char[] spec) {
      if(spec[0] == '<' || spec[1] == '>') { this.kind = Kind.aggr; }
      else if(spec[0] == '>' || spec[1] == '<') { this.kind = Kind.inp; }
      else { this.kind = Kind.src; }
      this.mdl = mdl;
      this.name = name;
      this.typeName = typeName;
      this.id = id;
      this.key = name !=null && name.length() >0 ? name: typeName;
      
    }
    
    @Override public String toString() {
      return this.mdl.name() + "." + this.name + "(" + this.id + ")";
    }
    
    public String info ( ) { return this.mdl.name() + "." + this.key; }
    
  }

  
  
  public static class XrefConn {
    
    public final String id;
    
    public final String name;
    
    private Port src;
    
    
    
    public XrefConn(String name, String id) {
      this.id = id;
      this.name = name;
    }
    
    
    void setSrc(Port src) { this.src = src; }
    
    public Port src() { return this.src; }
   
    
    @Override public String toString() { return "Xref " + this.name + "(" + this.id + "):" + this.src; }
    
  }
  
  
  
  /**
   * @author hartmut
   *
   */
  public final static class Connection {
    
    protected Port port1, port2;
    
    /**The original end points of a connection if they met a xref.
     * Then firstly (on construction) the adequate port is not set.
     * It is set later.
     */
    protected final XrefConn xref1, xref2;
    
    public final String name;
    
    public final String id;

    public Connection(String name, String id
        , Port port1, XrefConn xref1
        , Port port2, XrefConn xref2
        ) {
      assert(xref1==null ? port1 !=null : port1 == null);  // only one of them is set.
      assert(xref2==null ? port2 !=null : port2 == null);  // only one of them is set.
      this.port1 = port1;    //Note: port is not final 
      this.port2 = port2;
      this.xref1 = xref1;    //Note: xref is final
      this.xref2 = xref2;
      this.name = name;
      this.id = id;
    }


    @Override public String toString() {
      if(this.port1 !=null && this.port1.kind == Port.Kind.src) {
        return "connection" + " " + this.name + " " 
            + (this.port1 !=null ? this.port1.info() : this.xref1) + "-->" 
            + (this.port2 !=null ? this.port2.info() : this.xref2)
            + " (" + this.id + ")"
            ;
      } else {
        return "connection" + " " + this.name + " " 
            + (this.port2 !=null ? this.port2.info() : this.xref2) + "-->" 
            + (this.port1 !=null ? this.port1.info() : this.xref1)
            + " (" + this.id + ")"
            ;
      }
    }
    
    
  }


  public interface TextNode {
    
    String getText();
    
    public static String getText(TextNode node) {
      String text = null;
      return text;
    }
  }
  
  
  
  /**Class for Writing the Component Office_document_content.*/
  public static class Office_document_content extends XmlForOdg_Base.Office_document_content_Base {
  
  
    public String office_version;
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Office_automatic_styles.*/
  public static class Office_automatic_styles extends XmlForOdg_Base.Office_automatic_styles_Base {
  
  
  
    @Override public String toString ( ) { 
      return "contains all dedicated styles see idxStyle";
    }
  
    
    public Map<String, String> prepStyles() {
      Map<String, String> idxStyle = new TreeMap<String, String>();
      for(Style_style style: super.style_style) {
        idxStyle.put(style.style_name, style.style_parent_style_name);
      }
      return idxStyle;
    }
    
    
    
    
  }




  /**Class for Writing the Component Office_body.*/
  public static class Office_body extends XmlForOdg_Base.Office_body_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Office_font_face_decls.*/
  public static class Office_font_face_decls extends XmlForOdg_Base.Office_font_face_decls_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Style_style.*/
  public static class Style_style extends XmlForOdg_Base.Style_style_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return super.style_name + ":" + super.style_parent_style_name;
    }
  
  }




  /**Class for Writing the Component Text_list_style.*/
  public static class Text_list_style extends XmlForOdg_Base.Text_list_style_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Office_drawing.*/
  public static class Office_drawing extends XmlForOdg_Base.Office_drawing_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Style_font_face.*/
  public static class Style_font_face extends XmlForOdg_Base.Style_font_face_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Loext_graphic_properties.*/
  public static class Loext_graphic_properties extends XmlForOdg_Base.Loext_graphic_properties_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Style_graphic_properties.*/
  public static class Style_graphic_properties extends XmlForOdg_Base.Style_graphic_properties_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Style_paragraph_properties.*/
  public static class Style_paragraph_properties extends XmlForOdg_Base.Style_paragraph_properties_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Style_text_properties.*/
  public static class Style_text_properties extends XmlForOdg_Base.Style_text_properties_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Text_list_level_style_bullet.*/
  public static class Text_list_level_style_bullet extends XmlForOdg_Base.Text_list_level_style_bullet_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Draw_page.*/
  public static class Draw_page extends XmlForOdg_Base.Draw_page_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Style_list_level_properties.*/
  public static class Style_list_level_properties extends XmlForOdg_Base.Style_list_level_properties_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Draw_connector.*/
  public static class Draw_connector extends XmlForOdg_Base.Draw_connector_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Draw_custom_shape.*/
  public static class Draw_custom_shape extends XmlForOdg_Base.Draw_custom_shape_Base implements TextNode {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }

    @Override public String getText () {
      TextNode src = super.get_text_p();
      if(src !=null) { return src.getText(); }
      else return null;
    }
  
  }




  /**Class for Writing the Component Draw_frame.*/
  public static class Draw_frame extends XmlForOdg_Base.Draw_frame_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Draw_g.*/
  public static class Draw_g extends XmlForOdg_Base.Draw_g_Base {
  
  

  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Draw_polygon.*/
  public static class Draw_polygon extends XmlForOdg_Base.Draw_polygon_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Draw_polyline.*/
  public static class Draw_polyline extends XmlForOdg_Base.Draw_polyline_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Draw_enhanced_geometry.*/
  public static class Draw_enhanced_geometry extends XmlForOdg_Base.Draw_enhanced_geometry_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Text_p.*/
  public static class Text_p extends XmlForOdg_Base.Text_p_Base implements TextNode {
  
  
    @Override public String getText() {
      return super.text_s;
    }
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Draw_text_box.*/
  public static class Draw_text_box extends XmlForOdg_Base.Draw_text_box_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }








  /**Class for Writing the Component Draw_equation.*/
  public static class Draw_equation extends XmlForOdg_Base.Draw_equation_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Draw_handle.*/
  public static class Draw_handle extends XmlForOdg_Base.Draw_handle_Base {
  
  
  
  
  
    @Override public String toString ( ) { 
      return "TODO toString";
    }
  
  }




  /**Class for Writing the Component Text_span.*/
  public static class Text_span extends XmlForOdg_Base.Text_span_Base implements TextNode {
  
    @Override public String getText () {
      return super.get_text();
    }
  
    @Override public String toString ( ) { 
      return super.text;
    }

  }


}

